<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Memory Cube</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #1a1a2e;
      color: #eee;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: #16213e;
      padding: 16px;
      overflow-y: auto;
      border-right: 1px solid #0f3460;
    }

    .sidebar h1 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #e94560;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidebar h2 {
      font-size: 14px;
      text-transform: uppercase;
      color: #888;
      margin: 16px 0 8px 0;
      letter-spacing: 1px;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 16px;
    }

    .stat {
      background: #0f3460;
      padding: 12px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #e94560;
    }

    .stat-label {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
    }

    /* Filters */
    .filter-group {
      margin-bottom: 12px;
    }

    .filter-group label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }

    .filter-group select,
    .filter-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #0f3460;
      border-radius: 4px;
      background: #1a1a2e;
      color: #eee;
      font-size: 14px;
    }

    .filter-group select:focus,
    .filter-group input:focus {
      outline: none;
      border-color: #e94560;
    }

    /* Type chips filter */
    .type-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .type-chip {
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      cursor: pointer;
      border: 1px solid transparent;
      opacity: 0.5;
      transition: all 0.15s;
      text-transform: capitalize;
    }

    .type-chip:hover {
      opacity: 0.8;
    }

    .type-chip.active {
      opacity: 1;
      border-color: #fff;
    }

    .type-chip.all-types {
      background: #0f3460;
      color: #eee;
    }

    /* Search results dropdown */
    .search-results {
      max-height: 200px;
      overflow-y: auto;
      margin-top: 4px;
      border-radius: 4px;
      background: #0f3460;
      display: none;
    }

    .search-results.visible {
      display: block;
    }

    .search-result {
      padding: 8px 10px;
      cursor: pointer;
      font-size: 12px;
      border-bottom: 1px solid #1a1a2e;
    }

    .search-result:last-child {
      border-bottom: none;
    }

    .search-result:hover {
      background: #1a1a2e;
    }

    .search-result-type {
      font-size: 10px;
      color: #888;
      margin-left: 8px;
    }

    .btn {
      display: inline-block;
      padding: 8px 16px;
      background: #e94560;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 8px;
      margin-top: 8px;
    }

    .btn:hover {
      background: #ff6b6b;
    }

    .btn-secondary {
      background: #0f3460;
    }

    .btn-secondary:hover {
      background: #1a4a7a;
    }

    /* Graph container */
    .graph-container {
      flex: 1;
      position: relative;
    }

    #cy {
      width: 100%;
      height: 100%;
    }

    /* Node detail panel */
    .detail-panel {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 350px;
      max-height: calc(100vh - 32px);
      background: #16213e;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      display: none;
      overflow: hidden;
    }

    .detail-panel.active {
      display: block;
    }

    .detail-header {
      padding: 16px;
      background: #0f3460;
      border-bottom: 1px solid #1a1a2e;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .detail-header h3 {
      font-size: 16px;
      margin: 0;
    }

    .detail-close {
      background: none;
      border: none;
      color: #888;
      font-size: 20px;
      cursor: pointer;
    }

    .detail-close:hover {
      color: #e94560;
    }

    .detail-content {
      padding: 16px;
      overflow-y: auto;
      max-height: calc(100vh - 120px);
    }

    .detail-meta {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 16px;
    }

    .meta-item {
      background: #1a1a2e;
      padding: 8px;
      border-radius: 4px;
    }

    .meta-label {
      font-size: 10px;
      color: #888;
      text-transform: uppercase;
    }

    .meta-value {
      font-size: 14px;
      margin-top: 2px;
    }

    .tag {
      display: inline-block;
      padding: 2px 8px;
      background: #0f3460;
      border-radius: 12px;
      font-size: 12px;
      margin: 2px;
    }

    .detail-edges {
      margin-top: 16px;
    }

    .edge-item {
      display: flex;
      align-items: center;
      padding: 8px;
      background: #1a1a2e;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 13px;
    }

    .edge-type {
      color: #e94560;
      margin: 0 8px;
    }

    .edge-delete {
      margin-left: auto;
      background: none;
      border: none;
      color: #666;
      font-size: 16px;
      cursor: pointer;
      padding: 0 4px;
    }

    .edge-delete:hover {
      color: #e94560;
    }

    .detail-body {
      margin-top: 16px;
      padding: 12px;
      background: #1a1a2e;
      border-radius: 4px;
      font-size: 14px;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    /* Legend */
    .legend {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #0f3460;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      font-size: 12px;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      margin-right: 8px;
    }

    /* Loading */
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #888;
    }

    /* Empty state */
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
    }

    .empty-state.visible {
      display: block;
    }

    .empty-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .empty-text {
      color: #888;
      margin-bottom: 16px;
    }

    /* Mini-map */
    .minimap {
      position: absolute;
      bottom: 80px;
      right: 20px;
      width: 150px;
      height: 100px;
      background: rgba(22, 33, 62, 0.9);
      border: 1px solid #0f3460;
      border-radius: 6px;
      overflow: hidden;
      z-index: 100;
    }

    .minimap canvas {
      width: 100%;
      height: 100%;
    }

    .minimap-viewport {
      position: absolute;
      border: 2px solid #e94560;
      background: rgba(233, 69, 96, 0.1);
      pointer-events: none;
    }

    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 100;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      background: #16213e;
      border: 1px solid #0f3460;
      color: #eee;
      font-size: 18px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }

    .zoom-btn:hover {
      background: #0f3460;
      border-color: #e94560;
    }

    /* Shortcuts help */
    .shortcuts-help {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(22, 33, 62, 0.9);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      color: #888;
      display: none;
      z-index: 100;
    }

    .shortcuts-help.visible {
      display: block;
    }

    .shortcut-key {
      display: inline-block;
      background: #0f3460;
      padding: 2px 6px;
      border-radius: 3px;
      color: #eee;
      font-family: monospace;
      margin-right: 4px;
      margin-left: 8px;
    }

    .shortcut-key:first-child {
      margin-left: 0;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: #16213e;
      border: 1px solid #0f3460;
      border-radius: 6px;
      padding: 4px 0;
      min-width: 150px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      z-index: 1001;
      display: none;
    }

    .context-menu.visible {
      display: block;
    }

    .context-item {
      padding: 8px 12px;
      cursor: pointer;
      font-size: 13px;
    }

    .context-item:hover {
      background: #0f3460;
    }

    .context-item.danger {
      color: #e94560;
    }

    .context-divider {
      height: 1px;
      background: #0f3460;
      margin: 4px 0;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: #16213e;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      padding: 16px;
      background: #0f3460;
      border-radius: 12px 12px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      margin: 0;
    }

    .modal-form {
      padding: 16px;
    }

    .form-group {
      margin-bottom: 12px;
    }

    .form-group label {
      display: block;
      font-size: 12px;
      color: #888;
      margin-bottom: 4px;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #0f3460;
      border-radius: 6px;
      background: #1a1a2e;
      color: #eee;
      font-size: 14px;
      font-family: inherit;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 100px;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #e94560;
    }

    .form-row {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }

    .form-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #0f3460;
    }

    .btn-danger {
      background: #dc3545;
    }

    .btn-danger:hover {
      background: #c82333;
    }

    .detail-actions {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #0f3460;
      display: flex;
      gap: 8px;
    }

    /* Type colors */
    .type-task { background: #e94560; }
    .type-doc { background: #4ecdc4; }
    .type-code { background: #ffe66d; }
    .type-decision { background: #95e1d3; }
    .type-ideation { background: #f38181; }
    .type-brainfart { background: #aa96da; }
    .type-research { background: #fcbad3; }
    .type-conversation { background: #a8d8ea; }
    .type-concept { background: #f9ed69; }
    .type-event { background: #b8de6f; }
    .type-agent { background: #ff9a3c; }
    .type-project { background: #6a89cc; }
  </style>
</head>
<body>
  <div class="container">
    <aside class="sidebar">
      <h1>üßä Memory Cube</h1>
      
      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="stat-nodes">-</div>
          <div class="stat-label">Nodes</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="stat-edges">-</div>
          <div class="stat-label">Edges</div>
        </div>
      </div>

      <h2>Filters</h2>
      
      <div class="filter-group">
        <label>Type</label>
        <div class="type-chips" id="type-chips">
          <!-- Populated by JS -->
        </div>
      </div>

      <div class="filter-group">
        <label>Status</label>
        <select id="filter-status" onchange="loadGraph()">
          <option value="">All Statuses</option>
          <option value="pending">Pending</option>
          <option value="active">Active</option>
          <option value="blocked">Blocked</option>
          <option value="complete">Complete</option>
        </select>
      </div>

      <div class="filter-group">
        <label>Validity</label>
        <select id="filter-validity" onchange="loadGraph()">
          <option value="">All</option>
          <option value="current">Current</option>
          <option value="stale">Stale</option>
          <option value="superseded">Superseded</option>
        </select>
      </div>

      <div class="filter-group">
        <label>Search</label>
        <input type="text" id="filter-search" placeholder="Search nodes...">
        <div class="search-results" id="search-results"></div>
      </div>

      <button class="btn" onclick="loadGraph()">Apply Filters</button>
      <button class="btn btn-secondary" onclick="resetFilters()">Reset</button>
      
      <h2>Export</h2>
      <button class="btn btn-secondary" onclick="exportJSON()">üìÑ JSON</button>
      <button class="btn btn-secondary" onclick="exportPNG()">üñºÔ∏è PNG</button>

      <h2>Actions</h2>
      <button class="btn" onclick="showCreateModal()">+ New Node</button>
      <div style="margin-top: 8px;">
        <button class="btn btn-secondary" id="undo-btn" onclick="history.undo()" disabled title="Undo (Ctrl+Z)">‚Ü© Undo</button>
        <button class="btn btn-secondary" id="redo-btn" onclick="history.redo()" disabled title="Redo (Ctrl+Y)">‚Ü™ Redo</button>
      </div>

      <div class="legend">
        <h2>Node Types</h2>
        <div class="legend-item"><span class="legend-color type-task"></span> Task</div>
        <div class="legend-item"><span class="legend-color type-doc"></span> Doc</div>
        <div class="legend-item"><span class="legend-color type-code"></span> Code</div>
        <div class="legend-item"><span class="legend-color type-decision"></span> Decision</div>
        <div class="legend-item"><span class="legend-color type-ideation"></span> Ideation</div>
        <div class="legend-item"><span class="legend-color type-brainfart"></span> Brainfart</div>
        <div class="legend-item"><span class="legend-color type-research"></span> Research</div>
        <div class="legend-item"><span class="legend-color type-conversation"></span> Conversation</div>
        <div class="legend-item"><span class="legend-color type-concept"></span> Concept</div>
        <div class="legend-item"><span class="legend-color type-event"></span> Event</div>
        <div class="legend-item"><span class="legend-color type-agent"></span> Agent</div>
        <div class="legend-item"><span class="legend-color type-project"></span> Project</div>
      </div>
    </aside>

    <main class="graph-container">
      <div id="cy"></div>
      <div class="loading" id="loading">Loading graph...</div>
      <div class="empty-state" id="empty-state">
        <div class="empty-icon">üîç</div>
        <div class="empty-text">No nodes match your filters</div>
        <button class="btn btn-secondary" onclick="resetFilters()">Clear Filters</button>
      </div>
      
      <!-- Mini-map -->
      <div class="minimap" id="minimap">
        <canvas id="minimap-canvas" width="150" height="100"></canvas>
        <div class="minimap-viewport" id="minimap-viewport"></div>
      </div>

      <!-- Zoom controls -->
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()" title="Zoom In (+)">+</button>
        <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out (-)">‚àí</button>
        <button class="zoom-btn" onclick="fitGraph()" title="Fit to View (0)">‚ä°</button>
      </div>

      <!-- Keyboard shortcuts help -->
      <div class="shortcuts-help" id="shortcuts-help">
        <span class="shortcut-key">/</span> Search
        <span class="shortcut-key">n</span> New node
        <span class="shortcut-key">+</span> Zoom in
        <span class="shortcut-key">-</span> Zoom out
        <span class="shortcut-key">0</span> Fit
        <span class="shortcut-key">Esc</span> Close
        <span class="shortcut-key">?</span> Toggle help
      </div>
      
      <div class="detail-panel" id="detail-panel">
        <div class="detail-header">
          <h3 id="detail-title">Node Details</h3>
          <button class="detail-close" onclick="closeDetail()">√ó</button>
        </div>
        <div class="detail-content">
          <div class="detail-meta" id="detail-meta"></div>
          <div id="detail-tags"></div>
          <div class="detail-edges" id="detail-edges"></div>
          <div class="detail-body" id="detail-body"></div>
          <div class="detail-actions">
            <button class="btn btn-secondary" onclick="editCurrentNode()">‚úèÔ∏è Edit</button>
            <button class="btn btn-secondary" onclick="showAddEdgeModal()">üîó Link</button>
            <button class="btn btn-danger" onclick="deleteCurrentNode()">üóëÔ∏è Delete</button>
          </div>
        </div>
      </div>

      <!-- Create/Edit Modal -->
      <div class="modal-overlay" id="modal-overlay" onclick="closeModal()">
        <div class="modal" onclick="event.stopPropagation()">
          <div class="modal-header">
            <h3 id="modal-title">New Node</h3>
            <button class="detail-close" onclick="closeModal()">√ó</button>
          </div>
          <form class="modal-form" id="node-form" onsubmit="submitNodeForm(event)">
            <input type="hidden" id="form-id">
            
            <div class="form-group">
              <label for="form-title">Title *</label>
              <input type="text" id="form-title" required placeholder="Node title...">
            </div>

            <div class="form-row">
              <div class="form-group">
                <label for="form-type">Type *</label>
                <select id="form-type" required>
                  <option value="task">Task</option>
                  <option value="doc">Doc</option>
                  <option value="code">Code</option>
                  <option value="decision">Decision</option>
                  <option value="ideation">Ideation</option>
                  <option value="brainfart">Brainfart</option>
                  <option value="research">Research</option>
                  <option value="conversation">Conversation</option>
                  <option value="concept">Concept</option>
                  <option value="event">Event</option>
                  <option value="agent">Agent</option>
                  <option value="project">Project</option>
                </select>
              </div>

              <div class="form-group">
                <label for="form-status">Status</label>
                <select id="form-status">
                  <option value="pending">Pending</option>
                  <option value="active">Active</option>
                  <option value="blocked">Blocked</option>
                  <option value="complete">Complete</option>
                </select>
              </div>

              <div class="form-group">
                <label for="form-priority">Priority</label>
                <select id="form-priority">
                  <option value="normal">Normal</option>
                  <option value="high">High</option>
                  <option value="critical">Critical</option>
                  <option value="low">Low</option>
                </select>
              </div>
            </div>

            <div class="form-group">
              <label for="form-tags">Tags (comma-separated)</label>
              <input type="text" id="form-tags" placeholder="tag1, tag2, tag3">
            </div>

            <div class="form-group">
              <label for="form-content">Content</label>
              <textarea id="form-content" rows="6" placeholder="Node content (markdown supported)..."></textarea>
            </div>

            <div class="form-actions">
              <button type="button" class="btn btn-secondary" onclick="closeModal()">Cancel</button>
              <button type="submit" class="btn">Save Node</button>
            </div>
          </form>
        </div>
      </div>

      <!-- Context Menu -->
      <div class="context-menu" id="context-menu">
        <div class="context-item" onclick="contextEdit()">‚úèÔ∏è Edit</div>
        <div class="context-item" onclick="contextLink()">üîó Add Link</div>
        <div class="context-item" onclick="contextComplete()">‚úì Mark Complete</div>
        <div class="context-divider"></div>
        <div class="context-item danger" onclick="contextDelete()">üóëÔ∏è Delete</div>
      </div>

      <!-- Add Edge Modal -->
      <div class="modal-overlay" id="edge-modal-overlay" onclick="closeEdgeModal()">
        <div class="modal" onclick="event.stopPropagation()">
          <div class="modal-header">
            <h3>Add Relationship</h3>
            <button class="detail-close" onclick="closeEdgeModal()">√ó</button>
          </div>
          <form class="modal-form" onsubmit="submitEdgeForm(event)">
            <div class="form-group">
              <label>From</label>
              <input type="text" id="edge-from" readonly>
            </div>

            <div class="form-group">
              <label for="edge-type">Relationship Type *</label>
              <select id="edge-type" required>
                <option value="depends-on">Depends On</option>
                <option value="blocks">Blocks</option>
                <option value="implements">Implements</option>
                <option value="documents">Documents</option>
                <option value="relates-to">Relates To</option>
                <option value="part-of">Part Of</option>
                <option value="spawns">Spawns</option>
                <option value="supersedes">Supersedes</option>
                <option value="derived-from">Derived From</option>
              </select>
            </div>

            <div class="form-group">
              <label for="edge-to">To (Node ID) *</label>
              <select id="edge-to" required>
                <!-- Populated by JS -->
              </select>
            </div>

            <div class="form-actions">
              <button type="button" class="btn btn-secondary" onclick="closeEdgeModal()">Cancel</button>
              <button type="submit" class="btn">Create Link</button>
            </div>
          </form>
        </div>
      </div>
    </main>
  </div>

  <script>
    let cy = null;

    // Node colors by type
    const typeColors = {
      task: '#e94560',
      doc: '#4ecdc4',
      code: '#ffe66d',
      decision: '#95e1d3',
      ideation: '#f38181',
      brainfart: '#aa96da',
      research: '#fcbad3',
      conversation: '#a8d8ea',
      concept: '#f9ed69',
      event: '#b8de6f',
      agent: '#ff9a3c',
      project: '#6a89cc',
    };

    // Initialize Cytoscape
    function initCytoscape() {
      cy = cytoscape({
        container: document.getElementById('cy'),
        style: [
          {
            selector: 'node',
            style: {
              'label': 'data(label)',
              'text-valign': 'bottom',
              'text-halign': 'center',
              'font-size': '10px',
              'color': '#ccc',
              'text-margin-y': 5,
              'width': 30,
              'height': 30,
              'background-color': '#666',
              'border-width': 2,
              'border-color': '#444',
              'text-max-width': '100px',
              'text-wrap': 'ellipsis',
              'text-overflow-wrap': 'anywhere',
            }
          },
          {
            selector: 'edge',
            style: {
              'width': 2,
              'line-color': '#444',
              'target-arrow-color': '#444',
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'arrow-scale': 0.8,
              'label': 'data(type)',
              'font-size': '9px',
              'color': '#666',
              'text-opacity': 0,
              'text-rotation': 'autorotate',
              'text-margin-y': -8,
            }
          },
          {
            selector: 'edge:active, edge.hover',
            style: {
              'text-opacity': 1,
              'color': '#aaa',
            }
          },
          {
            selector: 'node:selected',
            style: {
              'border-width': 4,
              'border-color': '#fff',
            }
          },
          // Type-specific colors
          ...Object.entries(typeColors).map(([type, color]) => ({
            selector: `node.${type}`,
            style: { 'background-color': color }
          })),
          // Status styles
          {
            selector: 'node.complete',
            style: { 
              'opacity': 0.7,
              'border-color': '#4ecdc4',
              'border-width': 3
            }
          },
          {
            selector: 'node.blocked',
            style: { 
              'border-style': 'dashed',
              'border-color': '#e94560'
            }
          },
          {
            selector: 'node.active',
            style: {
              'border-color': '#ffe66d',
              'border-width': 3
            }
          },
          // Edge type colors
          {
            selector: 'edge.blocks, edge.blocked-by',
            style: { 'line-color': '#e94560', 'target-arrow-color': '#e94560' }
          },
          {
            selector: 'edge.depends-on',
            style: { 'line-color': '#ffe66d', 'target-arrow-color': '#ffe66d' }
          },
          {
            selector: 'edge.implements',
            style: { 'line-color': '#4ecdc4', 'target-arrow-color': '#4ecdc4' }
          },
          // Hover states
          {
            selector: '.dimmed',
            style: { 'opacity': 0.15 }
          },
          {
            selector: 'node.highlighted',
            style: { 
              'border-width': 4,
              'border-color': '#fff',
              'z-index': 999,
              'text-max-width': '200px',
              'font-size': '12px',
            }
          },
        ],
        layout: {
          name: 'cose',
          animate: false,
          nodeRepulsion: 8000,
          idealEdgeLength: 100,
        },
      });

      // Click handler
      cy.on('tap', 'node', (evt) => {
        const nodeId = evt.target.id();
        showNodeDetail(nodeId);
      });

      // Double-click to edit
      cy.on('dbltap', 'node', (evt) => {
        currentNodeId = evt.target.id();
        editCurrentNode();
      });

      cy.on('tap', (evt) => {
        if (evt.target === cy) {
          closeDetail();
        }
      });

      // Right-click context menu
      cy.on('cxttap', 'node', (evt) => {
        const node = evt.target;
        currentNodeId = node.id();
        
        const menu = document.getElementById('context-menu');
        const pos = evt.renderedPosition;
        const container = document.querySelector('.graph-container').getBoundingClientRect();
        
        menu.style.left = (container.left + pos.x) + 'px';
        menu.style.top = (container.top + pos.y) + 'px';
        menu.classList.add('visible');
        
        evt.originalEvent.preventDefault();
      });

      // Hide context menu on click elsewhere
      document.addEventListener('click', () => {
        document.getElementById('context-menu').classList.remove('visible');
      });

      // Hover highlight for connected nodes
      cy.on('mouseover', 'node', (evt) => {
        const node = evt.target;
        const connected = node.neighborhood().add(node);
        
        cy.elements().addClass('dimmed');
        connected.removeClass('dimmed');
        node.addClass('highlighted');
        
        // Show edge labels for connected edges
        node.connectedEdges().addClass('hover');
      });

      cy.on('mouseout', 'node', () => {
        cy.elements().removeClass('dimmed').removeClass('highlighted');
        cy.edges().removeClass('hover');
      });

      // Edge hover for label
      cy.on('mouseover', 'edge', (evt) => {
        evt.target.addClass('hover');
      });

      cy.on('mouseout', 'edge', (evt) => {
        evt.target.removeClass('hover');
      });
    }

    // Load graph data
    async function loadGraph() {
      document.getElementById('loading').style.display = 'block';

      const params = new URLSearchParams();
      
      // Use active types from chips
      if (activeTypes.size > 0) {
        params.set('type', Array.from(activeTypes).join(','));
      }
      
      const status = document.getElementById('filter-status').value;
      if (status) params.set('status', status);
      
      const validity = document.getElementById('filter-validity').value;
      if (validity) params.set('validity', validity);
      
      const search = document.getElementById('filter-search').value;
      if (search) params.set('search', search);

      try {
        const res = await fetch(`/api/graph?${params}`);
        const data = await res.json();

        cy.elements().remove();
        cy.add(data.nodes);
        cy.add(data.edges);

        cy.layout({
          name: 'cose',
          animate: true,
          animationDuration: 500,
          nodeRepulsion: 8000,
          idealEdgeLength: 100,
        }).run();

        document.getElementById('stat-nodes').textContent = data.nodes.length;
        document.getElementById('stat-edges').textContent = data.edges.length;

        // Show/hide empty state
        if (data.nodes.length === 0) {
          document.getElementById('empty-state').classList.add('visible');
        } else {
          document.getElementById('empty-state').classList.remove('visible');
        }
        
        // Update minimap after layout settles
        setTimeout(updateMinimap, 600);
      } catch (err) {
        console.error('Failed to load graph:', err);
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }

    // Show node details
    async function showNodeDetail(nodeId) {
      currentNodeId = nodeId;
      try {
        const res = await fetch(`/api/node?id=${encodeURIComponent(nodeId)}`);
        const data = await res.json();
        const node = data.node;

        document.getElementById('detail-title').textContent = node.title;
        
        document.getElementById('detail-meta').innerHTML = `
          <div class="meta-item">
            <div class="meta-label">Type</div>
            <div class="meta-value">${node.type}</div>
          </div>
          <div class="meta-item">
            <div class="meta-label">Status</div>
            <div class="meta-value">${node.status}</div>
          </div>
          <div class="meta-item">
            <div class="meta-label">Priority</div>
            <div class="meta-value">${node.priority}</div>
          </div>
          <div class="meta-item">
            <div class="meta-label">Validity</div>
            <div class="meta-value">${node.validity}</div>
          </div>
        `;

        document.getElementById('detail-tags').innerHTML = node.tags.length 
          ? node.tags.map(t => `<span class="tag">${t}</span>`).join('')
          : '<span style="color:#666">No tags</span>';

        if (node.edges.length > 0) {
          document.getElementById('detail-edges').innerHTML = `
            <h4 style="font-size:12px;color:#888;margin-bottom:8px">RELATIONSHIPS</h4>
            ${node.edges.map(e => `
              <div class="edge-item">
                <span>this</span>
                <span class="edge-type">‚Üí ${e.type} ‚Üí</span>
                <span>${e.to.split('/').pop()}</span>
                <button class="edge-delete" onclick="deleteEdge('${node.id}', '${e.type}', '${e.to}')" title="Remove">√ó</button>
              </div>
            `).join('')}
          `;
        } else {
          document.getElementById('detail-edges').innerHTML = '';
        }

        document.getElementById('detail-body').textContent = node.content || '(no content)';

        document.getElementById('detail-panel').classList.add('active');
      } catch (err) {
        console.error('Failed to load node:', err);
      }
    }

    // Close detail panel
    function closeDetail() {
      document.getElementById('detail-panel').classList.remove('active');
      currentNodeId = null;
    }

    // Reset filters
    function resetFilters() {
      toggleAllTypes(); // Reset type chips
      document.getElementById('filter-status').value = '';
      document.getElementById('filter-validity').value = '';
      document.getElementById('filter-search').value = '';
      loadGraph();
    }

    // Active type filters (empty = all)
    let activeTypes = new Set();

    // Load type options as chips
    async function loadTypes() {
      try {
        const res = await fetch('/api/types');
        const data = await res.json();
        
        const container = document.getElementById('type-chips');
        container.innerHTML = `
          <span class="type-chip all-types active" onclick="toggleAllTypes()">All</span>
          ${data.types.map(t => `
            <span class="type-chip type-${t}" onclick="toggleTypeChip('${t}')" data-type="${t}">${t}</span>
          `).join('')}
        `;
      } catch (err) {
        console.error('Failed to load types:', err);
      }
    }

    // Toggle a specific type chip
    function toggleTypeChip(type) {
      const chip = document.querySelector(`.type-chip[data-type="${type}"]`);
      const allChip = document.querySelector('.type-chip.all-types');
      
      if (activeTypes.has(type)) {
        activeTypes.delete(type);
        chip.classList.remove('active');
      } else {
        activeTypes.add(type);
        chip.classList.add('active');
      }

      // Update "All" chip state
      if (activeTypes.size === 0) {
        allChip.classList.add('active');
      } else {
        allChip.classList.remove('active');
      }

      // Auto-apply filter
      loadGraph();
    }

    // Toggle all types (clear selection)
    function toggleAllTypes() {
      activeTypes.clear();
      document.querySelectorAll('.type-chip').forEach(c => c.classList.remove('active'));
      document.querySelector('.type-chip.all-types').classList.add('active');
      loadGraph();
    }

    // Zoom functions
    function zoomIn() {
      cy.zoom(cy.zoom() * 1.2);
      cy.center();
    }

    function zoomOut() {
      cy.zoom(cy.zoom() / 1.2);
      cy.center();
    }

    function fitGraph() {
      cy.fit(cy.elements(), 50);
    }

    // Toggle shortcuts help
    function toggleHelp() {
      document.getElementById('shortcuts-help').classList.toggle('visible');
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Don't trigger if typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
        if (e.key === 'Escape') {
          e.target.blur();
        }
        return;
      }

      switch (e.key) {
        case '/':
          e.preventDefault();
          document.getElementById('filter-search').focus();
          break;
        case '+':
        case '=':
          e.preventDefault();
          zoomIn();
          break;
        case '-':
          e.preventDefault();
          zoomOut();
          break;
        case '0':
          e.preventDefault();
          fitGraph();
          break;
        case 'Escape':
          closeDetail();
          break;
        case '?':
          e.preventDefault();
          toggleHelp();
          break;
        case 'r':
          if (!e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            loadGraph();
          }
          break;
        case 'n':
          e.preventDefault();
          showCreateModal();
          break;
        case 'z':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            history.undo();
          }
          break;
        case 'y':
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            history.redo();
          }
          break;
      }
    });

    // Current node being viewed (for edit/delete)
    let currentNodeId = null;

    // Undo/redo history
    const history = {
      past: [],
      future: [],
      maxSize: 50,
      
      push(action) {
        this.past.push(action);
        this.future = []; // Clear redo stack on new action
        if (this.past.length > this.maxSize) this.past.shift();
        this.updateButtons();
      },
      
      canUndo() { return this.past.length > 0; },
      canRedo() { return this.future.length > 0; },
      
      async undo() {
        if (!this.canUndo()) return;
        const action = this.past.pop();
        this.future.push(action);
        await this.revert(action);
        this.updateButtons();
      },
      
      async redo() {
        if (!this.canRedo()) return;
        const action = this.future.pop();
        this.past.push(action);
        await this.apply(action);
        this.updateButtons();
      },
      
      async revert(action) {
        try {
          switch (action.type) {
            case 'create':
              await fetch(`/api/node?id=${encodeURIComponent(action.nodeId)}`, { method: 'DELETE' });
              break;
            case 'delete':
              await fetch('/api/node', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(action.data)
              });
              break;
            case 'update':
              await fetch('/api/node', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: action.nodeId, ...action.oldData })
              });
              break;
            case 'link':
              await fetch('/api/edge', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(action.edge)
              });
              break;
            case 'unlink':
              await fetch('/api/edge', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(action.edge)
              });
              break;
          }
          loadGraph();
        } catch (err) {
          console.error('Undo failed:', err);
        }
      },
      
      async apply(action) {
        try {
          switch (action.type) {
            case 'create':
              await fetch('/api/node', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(action.data)
              });
              break;
            case 'delete':
              await fetch(`/api/node?id=${encodeURIComponent(action.nodeId)}`, { method: 'DELETE' });
              break;
            case 'update':
              await fetch('/api/node', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: action.nodeId, ...action.newData })
              });
              break;
            case 'link':
              await fetch('/api/edge', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(action.edge)
              });
              break;
            case 'unlink':
              await fetch('/api/edge', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(action.edge)
              });
              break;
          }
          loadGraph();
        } catch (err) {
          console.error('Redo failed:', err);
        }
      },
      
      updateButtons() {
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        if (undoBtn) undoBtn.disabled = !this.canUndo();
        if (redoBtn) redoBtn.disabled = !this.canRedo();
      }
    };

    // Context menu actions
    function contextEdit() {
      if (!currentNodeId) return;
      editCurrentNode();
    }

    function contextLink() {
      if (!currentNodeId) return;
      showAddEdgeModal();
    }

    async function contextComplete() {
      if (!currentNodeId) return;
      
      try {
        const res = await fetch('/api/node', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: currentNodeId, status: 'complete' }),
        });

        if (!res.ok) {
          const result = await res.json();
          alert('Error: ' + (result.error || 'Unknown error'));
          return;
        }

        loadGraph();
      } catch (err) {
        alert('Error: ' + err.message);
      }
    }

    function contextDelete() {
      if (!currentNodeId) return;
      deleteCurrentNode();
    }

    // Modal functions
    function showCreateModal() {
      document.getElementById('modal-title').textContent = 'New Node';
      document.getElementById('form-id').value = '';
      document.getElementById('node-form').reset();
      document.getElementById('modal-overlay').classList.add('active');
      document.getElementById('form-title').focus();
    }

    function showEditModal(node) {
      document.getElementById('modal-title').textContent = 'Edit Node';
      document.getElementById('form-id').value = node.id;
      document.getElementById('form-title').value = node.title;
      document.getElementById('form-type').value = node.type;
      document.getElementById('form-status').value = node.status;
      document.getElementById('form-priority').value = node.priority;
      document.getElementById('form-tags').value = (node.tags || []).join(', ');
      document.getElementById('form-content').value = node.content || '';
      document.getElementById('modal-overlay').classList.add('active');
    }

    function closeModal() {
      document.getElementById('modal-overlay').classList.remove('active');
    }

    async function submitNodeForm(e) {
      e.preventDefault();
      
      const id = document.getElementById('form-id').value;
      const data = {
        title: document.getElementById('form-title').value,
        type: document.getElementById('form-type').value,
        status: document.getElementById('form-status').value,
        priority: document.getElementById('form-priority').value,
        tags: document.getElementById('form-tags').value.split(',').map(t => t.trim()).filter(Boolean),
        content: document.getElementById('form-content').value,
      };

      try {
        const isEdit = !!id;
        
        // Get old data for undo if editing
        let oldData = null;
        if (isEdit) {
          const oldRes = await fetch(`/api/node?id=${encodeURIComponent(id)}`);
          const oldResult = await oldRes.json();
          if (oldResult.node) {
            oldData = {
              title: oldResult.node.title,
              type: oldResult.node.type,
              status: oldResult.node.status,
              priority: oldResult.node.priority,
              tags: oldResult.node.tags,
              content: oldResult.node.content,
            };
          }
        }
        
        const res = await fetch('/api/node', {
          method: isEdit ? 'PUT' : 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(isEdit ? { id, ...data } : data),
        });

        const result = await res.json();
        
        if (!res.ok) {
          alert('Error: ' + (result.error || 'Unknown error'));
          return;
        }

        // Record history
        if (isEdit) {
          history.push({ type: 'update', nodeId: id, oldData, newData: data });
        } else {
          history.push({ type: 'create', nodeId: result.node.id, data });
        }

        closeModal();
        loadGraph();
        
        if (isEdit && currentNodeId === id) {
          showNodeDetail(id);
        }
      } catch (err) {
        alert('Error: ' + err.message);
      }
    }

    function editCurrentNode() {
      if (!currentNodeId) return;
      fetch(`/api/node?id=${encodeURIComponent(currentNodeId)}`)
        .then(r => r.json())
        .then(data => showEditModal(data.node))
        .catch(err => alert('Error: ' + err.message));
    }

    async function deleteCurrentNode() {
      if (!currentNodeId) return;
      if (!confirm('Delete this node? (You can undo with Ctrl+Z)')) return;

      try {
        // Get node data for undo
        const oldRes = await fetch(`/api/node?id=${encodeURIComponent(currentNodeId)}`);
        const oldResult = await oldRes.json();
        
        const res = await fetch(`/api/node?id=${encodeURIComponent(currentNodeId)}`, {
          method: 'DELETE',
        });

        if (!res.ok) {
          const result = await res.json();
          alert('Error: ' + (result.error || 'Unknown error'));
          return;
        }

        // Record history
        if (oldResult.node) {
          history.push({ 
            type: 'delete', 
            nodeId: currentNodeId, 
            data: {
              type: oldResult.node.type,
              title: oldResult.node.title,
              content: oldResult.node.content,
              status: oldResult.node.status,
              priority: oldResult.node.priority,
              tags: oldResult.node.tags,
            }
          });
        }

        closeDetail();
        loadGraph();
      } catch (err) {
        alert('Error: ' + err.message);
      }
    }

    // Edge modal functions
    async function showAddEdgeModal() {
      if (!currentNodeId) return;
      
      document.getElementById('edge-from').value = currentNodeId;
      
      // Load all nodes for the target dropdown
      try {
        const res = await fetch('/api/nodes?limit=1000');
        const data = await res.json();
        
        const select = document.getElementById('edge-to');
        select.innerHTML = data.nodes
          .filter(n => n.id !== currentNodeId)
          .map(n => `<option value="${n.id}">${n.title} (${n.type})</option>`)
          .join('');
          
        document.getElementById('edge-modal-overlay').classList.add('active');
      } catch (err) {
        alert('Error loading nodes: ' + err.message);
      }
    }

    function closeEdgeModal() {
      document.getElementById('edge-modal-overlay').classList.remove('active');
    }

    async function deleteEdge(from, type, to) {
      if (!confirm(`Remove "${type}" relationship? (Ctrl+Z to undo)`)) return;

      const edge = { from, type, to };

      try {
        const res = await fetch('/api/edge', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(edge),
        });

        if (!res.ok) {
          const result = await res.json();
          alert('Error: ' + (result.error || 'Unknown error'));
          return;
        }

        // Record history
        history.push({ type: 'unlink', edge });

        loadGraph();
        showNodeDetail(currentNodeId);
      } catch (err) {
        alert('Error: ' + err.message);
      }
    }

    async function submitEdgeForm(e) {
      e.preventDefault();
      
      const edge = {
        from: document.getElementById('edge-from').value,
        type: document.getElementById('edge-type').value,
        to: document.getElementById('edge-to').value,
      };

      try {
        const res = await fetch('/api/edge', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(edge),
        });

        const result = await res.json();
        
        if (!res.ok) {
          alert('Error: ' + (result.error || 'Unknown error'));
          return;
        }

        // Record history
        history.push({ type: 'link', edge });

        closeEdgeModal();
        loadGraph();
        showNodeDetail(currentNodeId);
      } catch (err) {
        alert('Error: ' + err.message);
      }
    }

    // Export functions
    function exportJSON() {
      const data = {
        nodes: cy.nodes().map(n => n.data()),
        edges: cy.edges().map(e => e.data()),
        exportedAt: new Date().toISOString(),
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `memory-cube-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function exportPNG() {
      const png = cy.png({ 
        output: 'blob', 
        bg: '#1a1a2e',
        scale: 2,
        full: true
      });
      
      const url = URL.createObjectURL(png);
      const a = document.createElement('a');
      a.href = url;
      a.download = `memory-cube-${Date.now()}.png`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // Debounce helper
    function debounce(fn, ms) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), ms);
      };
    }

    // Auto-apply search filter on typing + show results dropdown
    const debouncedSearch = debounce(() => {
      loadGraph();
      showSearchResults();
    }, 300);
    document.getElementById('filter-search').addEventListener('input', debouncedSearch);
    
    // Hide search results when clicking elsewhere
    document.getElementById('filter-search').addEventListener('blur', () => {
      setTimeout(() => {
        document.getElementById('search-results').classList.remove('visible');
      }, 200);
    });

    async function showSearchResults() {
      const search = document.getElementById('filter-search').value.trim();
      const resultsDiv = document.getElementById('search-results');
      
      if (!search) {
        resultsDiv.classList.remove('visible');
        return;
      }

      try {
        const res = await fetch(`/api/nodes?search=${encodeURIComponent(search)}&limit=10`);
        const data = await res.json();
        
        if (data.nodes.length === 0) {
          resultsDiv.innerHTML = '<div class="search-result" style="color:#888">No results</div>';
        } else {
          resultsDiv.innerHTML = data.nodes.map(n => `
            <div class="search-result" onclick="focusNode('${n.id}')">
              ${n.title}<span class="search-result-type">${n.type}</span>
            </div>
          `).join('');
        }
        
        resultsDiv.classList.add('visible');
      } catch (err) {
        console.error('Search error:', err);
      }
    }

    function focusNode(nodeId) {
      document.getElementById('search-results').classList.remove('visible');
      
      const node = cy.getElementById(nodeId);
      if (node.length > 0) {
        cy.animate({
          center: { eles: node },
          zoom: 1.5
        }, {
          duration: 300
        });
        
        node.select();
        showNodeDetail(nodeId);
      }
    }

    // Mini-map
    function updateMinimap() {
      const canvas = document.getElementById('minimap-canvas');
      const ctx = canvas.getContext('2d');
      const viewport = document.getElementById('minimap-viewport');
      
      if (!cy || cy.nodes().length === 0) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        viewport.style.display = 'none';
        return;
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Get bounding box of all elements
      const bb = cy.elements().boundingBox();
      const padding = 10;
      
      // Calculate scale
      const scaleX = (canvas.width - padding * 2) / bb.w;
      const scaleY = (canvas.height - padding * 2) / bb.h;
      const scale = Math.min(scaleX, scaleY, 1);
      
      // Draw nodes
      cy.nodes().forEach(node => {
        const pos = node.position();
        const x = padding + (pos.x - bb.x1) * scale;
        const y = padding + (pos.y - bb.y1) * scale;
        
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = typeColors[node.data('type')] || '#666';
        ctx.fill();
      });
      
      // Draw edges
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 0.5;
      cy.edges().forEach(edge => {
        const source = edge.source().position();
        const target = edge.target().position();
        
        ctx.beginPath();
        ctx.moveTo(padding + (source.x - bb.x1) * scale, padding + (source.y - bb.y1) * scale);
        ctx.lineTo(padding + (target.x - bb.x1) * scale, padding + (target.y - bb.y1) * scale);
        ctx.stroke();
      });
      
      // Update viewport indicator
      const ext = cy.extent();
      const vx = padding + (ext.x1 - bb.x1) * scale;
      const vy = padding + (ext.y1 - bb.y1) * scale;
      const vw = ext.w * scale;
      const vh = ext.h * scale;
      
      viewport.style.display = 'block';
      viewport.style.left = Math.max(0, vx) + 'px';
      viewport.style.top = Math.max(0, vy) + 'px';
      viewport.style.width = Math.min(vw, canvas.width) + 'px';
      viewport.style.height = Math.min(vh, canvas.height) + 'px';
    }

    // Update minimap on pan/zoom
    function setupMinimapUpdates() {
      cy.on('pan zoom', debounce(updateMinimap, 100));
      cy.on('add remove', debounce(updateMinimap, 100));
    }

    // Initialize
    initCytoscape();
    setupMinimapUpdates();
    loadTypes();
    loadGraph();
  </script>
</body>
</html>
